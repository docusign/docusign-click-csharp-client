/* 
 * DocuSign Click API
 *
 * Elastic signing (also known as DocuSign Click)  lets you capture consent to standard agreement terms with a single click: terms and conditions, terms of service, terms of use, privacy policies, and more. The Click API lets you include this customizable elastic template solution in your DocuSign integrations.
 *
 * OpenAPI spec version: v1
 * Contact: devcenter@docusign.com
 * Generated by: https://github.com/swagger-api/swagger-codegen.git
 */

using DocuSign.Click.Client.Auth;
using Microsoft.IdentityModel.JsonWebTokens;
using Microsoft.IdentityModel.Tokens;
using Newtonsoft.Json;
using Org.BouncyCastle.Crypto;
using Org.BouncyCastle.Crypto.Parameters;
using Org.BouncyCastle.OpenSsl;
using Org.BouncyCastle.Security;
using System;
using System.Collections;
using System.Collections.Generic;
using System.IO;
using System.Linq;
using System.Net;
using System.Net.Http;
using System.Runtime.Serialization;
using System.Security.Claims;
using System.Security.Cryptography;
using System.Text;
using System.Text.RegularExpressions;
using System.Threading;
using System.Threading.Tasks;

namespace DocuSign.Click.Client
{
    /// <summary>
    /// DocuSignClient is mainly responsible for facilitating HTTP calls to the Docusign APIs.
    /// </summary>
    public class DocuSignClient
    {
        // Rest API base path constants
        // Live/Production base path
        public const string Production_REST_BasePath = "https://www.docusign.net/clickapi";
        // Sandbox/Demo base path 
        public const string Demo_REST_BasePath = "https://demo.docusign.net/restapi";
        // Stage base path
        public const string Stage_REST_BasePath = "https://stage.docusign.net/restapi";

        protected string basePath = Demo_REST_BasePath;

        protected Uri baseUri => Uri.TryCreate(basePath, UriKind.Absolute, out Uri uri) ? uri : new Uri(Demo_REST_BasePath);

        protected string oAuthBasePath = OAuth.Demo_OAuth_BasePath;

        protected string oAuthBasePathWithScheme => $"https://{oAuthBasePath}/";

        protected Uri oAuthBaseUri => Uri.TryCreate(oAuthBasePathWithScheme, UriKind.Absolute, out Uri uri) ? uri : new Uri(OAuth.Demo_OAuth_BasePath);

        protected JsonSerializerSettings serializerSettings = new JsonSerializerSettings
        {
            ConstructorHandling = ConstructorHandling.AllowNonPublicDefaultConstructor
        };

        /// <summary>
        /// Allows for extending request processing for <see cref="DocuSignClient"/> generated code.
        /// </summary>
        /// <param name="request">The IHttpClient request object</param>
        public virtual void InterceptRequest(DocuSignRequest request)
        {
            // Override this to add telemetry
        }

        /// <summary>
        /// Allows for extending response processing for <see cref="DocuSignClient"/> generated code.
        /// </summary>
        /// <param name="request">The <see cref="DocuSignRequest"/> request object</param>
        /// <param name="response">The <see cref="DocuSignResponse"/> response object</param>
        public virtual void InterceptResponse(DocuSignRequest request, DocuSignResponse response)
        {
            // Override this to add telemetry
        }

        /// <summary>
        /// Initializes a new instance of <see cref="DocuSignClient"/> with default
        /// with default base path (https://demo.docusign.net/restapi).
        /// </summary>
        public DocuSignClient()
        {
            Configuration = new Configuration();

            SetBasePath(Demo_REST_BasePath);
            RestClient = buildDefaultHttpClient();

            SetOAuthBasePath();

            RestClient.AddDefaultRequestHeader("User-Agent", Configuration.UserAgent);
        }

        /// <summary>
        /// Initializes a new instance of <see cref="DocuSignClient"/> using
        /// the provided configuration with the default base path (https://demo.docusign.net/restapi).
        /// </summary>
        /// <param name="configuration">Provided pre-populated <see cref="Configuration"/> object</param>
        public DocuSignClient(Configuration configuration)
        {
            Configuration = configuration ?? new Configuration();

            SetBasePath(string.IsNullOrEmpty(configuration.BasePath) ? Demo_REST_BasePath : configuration.BasePath);
            RestClient = buildDefaultHttpClient(configuration?.Timeout ?? Configuration.DefaultTimeoutValue);

            SetOAuthBasePath();

            RestClient.AddDefaultRequestHeader("User-Agent", Configuration.UserAgent);
        }

        /// <summary>
        /// Initializes a new instance of <see cref="DocuSignClient" /> configured with
        /// the provided API base path and optional <see cref="IWebProxy"/> object
        /// </summary>
        /// <param name="apiBase">The API base path</param>
        /// <param name="proxy">An optional IWebProxy instance</param>
        /// <exception cref="ArgumentException">Thwon when apiBase is null or empty</exception>
        public DocuSignClient(String apiBase, IWebProxy proxy = null)
        {
            if (String.IsNullOrEmpty(apiBase))
                throw new ArgumentException("apiBase cannot be empty");

            RestClient = buildDefaultHttpClient(Configuration.DefaultTimeoutValue, proxy);
            Configuration = new Configuration(apiBase);

            RestClient.AddDefaultRequestHeader("User-Agent", Configuration.UserAgent);

            this.SetBasePath(apiBase);
            this.SetOAuthBasePath();
        }

        /// <summary>
        /// Initializes a  new instance of <see cref="DocuSignClient"/> with the provided
        /// API base path, OAuth base path, and optional <see cref="IWebProxy"/> object
        /// </summary>
        /// <param name="apiBase">The API base path</param>
        /// <param name="oAuthBase">The oAuth base path</param>
        /// <param name="proxy">An optional IWebProxy instance</param>
        /// <exception cref="ArgumentException">Thrown when apiBase or oAuthBase are null or empty</exception>
        public DocuSignClient(String apiBase, String oAuthBase, IWebProxy proxy = null)
        {
            if (String.IsNullOrEmpty(apiBase))
                throw new ArgumentException("apiBase cannot be empty");
            if (String.IsNullOrEmpty(oAuthBase))
                throw new ArgumentException("oAuthBase cannot be empty");

            RestClient = buildDefaultHttpClient(Configuration.DefaultTimeoutValue, proxy);
            Configuration = new Configuration(apiBase);

            this.SetBasePath(apiBase);
            this.SetOAuthBasePath(oAuthBase);
        }

        /// <summary>
        /// Initializes a new instance of <see cref="DocuSignClient"/> with the provided
        /// API base path and pre-configured <see cref="HttpClient"/> object
        /// </summary>
        /// <param name="apiBase">The API base path</param>
        /// <param name="apiClient">An instance of an <see cref="HttpClient"/> object</param>
        public DocuSignClient(string apiBase, HttpClient apiClient)
        {
            Configuration = new Configuration(apiBase);

            SetBasePath(apiBase);
            SetOAuthBasePath();

            RestClient = new SystemNetHttpClient(apiClient);
            RestClient.AddDefaultRequestHeader("User-Agent", Configuration.UserAgent);
        }

        /// <summary>
        /// Initializes a new instance of <see cref="DocuSignClient"/> with the provided
        /// API base path and pre-configured <see cref="IHttpClient"/> object
        /// </summary>
        /// <param name="apiBase"></param>
        /// <param name="client"></param>
        public DocuSignClient(string apiBase, IHttpClient client)
        {
            string baseUrl = string.IsNullOrEmpty(apiBase) ? Demo_REST_BasePath : apiBase;
            Configuration = new Configuration(baseUrl);

            SetBasePath(baseUrl);
            SetOAuthBasePath();

            RestClient = client;
            RestClient.AddDefaultRequestHeader("User-Agent", Configuration.UserAgent);
        }

        protected static IHttpClient buildDefaultHttpClient(int timeout = Configuration.DefaultTimeoutValue, IWebProxy proxy = null)
        {
            var httpClientHandler = new HttpClientHandler();
            if (proxy != null)
            {
                httpClientHandler.UseProxy = true;
                httpClientHandler.Proxy = proxy;
            }

            var httpClient = new HttpClient(httpClientHandler)
            {
                Timeout = TimeSpan.FromMilliseconds(timeout)
            };

            return new SystemNetHttpClient(httpClient);
        }

        public String GetBasePath() => baseUri.ToString();

        /// <summary>
        /// Gets or sets the Configuration.
        /// </summary>
        /// <value>An instance of the Configuration.</value>
        public Configuration Configuration { get; set; }

        /// <summary>
        /// Gets or sets the RestClient.
        /// </summary>
        /// <value>An instance of the RestClient</value>
        public IHttpClient RestClient { get; set; }

        public DocuSignRequest PrepareOAuthRequest(string oAuthBasePath, string path, HttpMethod method, List<KeyValuePair<string, string>> headerParams = null, List<KeyValuePair<string, string>> formParams = null)
        {
            string url = $"https://{oAuthBasePath}/{path}";
            
            if (!headerParams.Any(kvp => kvp.Key?.Equals("Content-Type") ?? false)) { headerParams.Add(new KeyValuePair<string, string>("Content-Type", "application/x-www-form-urlencoded")); }
            if (!headerParams.Any(kvp => kvp.Key?.Equals("Cache-Control") ?? false)) { headerParams.Add(new KeyValuePair<string, string>("Cache-Control", "no-store")); }
            if (!headerParams.Any(kvp => kvp.Key?.Equals("Pragma") ?? false)) { headerParams.Add(new KeyValuePair<string, string>("Pragma", "no-cache")); }
            return new DocuSignRequest(method, url, null, null, headerParams, formParams, null, null, "application/x-www-form-urlencoded");
        }

        public DocuSignRequest PrepareRequest(string path, HttpMethod method, List<KeyValuePair<string, string>> queryParams = null, object postBody = null, List<KeyValuePair<string, string>> headerParams = null,
                                                List<KeyValuePair<string, string>> formParams = null, List<KeyValuePair<string, string>> pathParams = null, List<FileParameter> fileParams = null, string contentType = null, string contentDisposition = null)
        {
            string url = $"{basePath}{path}";
            return new DocuSignRequest(method, url, queryParams, postBody, headerParams, formParams, pathParams, fileParams, contentType, contentDisposition);
        }

        public DocuSignResponse CallApi(DocuSignRequest request)
        {
            InterceptRequest(request);
            var response = RestClient.SendRequest(request);
            InterceptResponse(request, response);
            return response;
        }

        public async Task<DocuSignResponse> CallApiAsync(DocuSignRequest request)
        {
            InterceptRequest(request);
            CancellationTokenSource cts = new CancellationTokenSource();
            var response = await RestClient.SendRequestAsync(request, cts.Token);
            InterceptResponse(request, response);

            return response;
        }

        /// <summary>
        /// Escape string (url-encoded).
        /// </summary>
        /// <param name="str">String to be escaped.</param>
        /// <returns>Escaped string.</returns>
        public string EscapeString(string str)
        {
            return UrlEncode(str);
        }

        /// <summary>
        /// Create FileParameter based on Stream.
        /// </summary>
        /// <param name="name">Parameter name.</param>
        /// <param name="stream">Input stream.</param>
        /// <returns>FileParameter.</returns>
        public FileParameter ParameterToFile(string name, Stream stream)
        {
            if (stream is FileStream)
                return new FileParameter(name, Path.GetFileName(((FileStream)stream).Name), $"form-data;filename={Path.GetFileName(((FileStream)stream).Name)};name={name};", ReadAsBytes(stream));
            else
                return new FileParameter(name, "no_file_name_provided", $"form-data;filename=no_file_name_provided;name={name}", ReadAsBytes(stream));
        }

        /// <summary>
        /// If parameter is DateTime, output in a formatted string (default ISO 8601), customizable with Configuration.DateTime.
        /// If parameter is a list, join the list with ",".
        /// Otherwise just return the string.
        /// </summary>
        /// <param name="obj">The parameter (header, path, query, form).</param>
        /// <returns>Formatted string.</returns>
        public string ParameterToString(object obj)
        {
            if (obj is DateTime)
                // Return a formatted date string - Can be customized with Configuration.DateTimeFormat
                // Defaults to an ISO 8601, using the known as a Round-trip date/time pattern ("o")
                // https://msdn.microsoft.com/en-us/library/az4se3k1(v=vs.110).aspx#Anchor_8
                // For example: 2009-06-15T13:45:30.0000000
                return ((DateTime)obj).ToString(Configuration.DateTimeFormat);
            else if (obj is DateTimeOffset)
                // Return a formatted date string - Can be customized with Configuration.DateTimeFormat
                // Defaults to an ISO 8601, using the known as a Round-trip date/time pattern ("o")
                // https://msdn.microsoft.com/en-us/library/az4se3k1(v=vs.110).aspx#Anchor_8
                // For example: 2009-06-15T13:45:30.0000000
                return ((DateTimeOffset)obj).ToString(Configuration.DateTimeFormat);
            else if (obj is IList)
            {
                var flattenedString = new StringBuilder();
                foreach (var param in (IList)obj)
                {
                    if (flattenedString.Length > 0)
                        flattenedString.Append(",");
                    flattenedString.Append(param);
                }
                return flattenedString.ToString();
            }
            else
                return Convert.ToString(obj);
        }

        /// <summary>
        /// Deserialize the JSON string into a proper object.
        /// </summary>
        /// <param name="response">The HTTP response.</param>
        /// <param name="type">Object type.</param>
        /// <returns>Object representation of the JSON string.</returns>
        public object Deserialize(DocuSignResponse response, Type type)
        {
            if (type == typeof(byte[])) // return byte array
            {
                return Encoding.UTF8.GetBytes(response.Content);
            }

            if (type == typeof(Stream))
            {
                return new MemoryStream(response.RawBytes);
            }

            if (type.Name.StartsWith("System.Nullable`1[[System.DateTime")) // return a datetime object
            {
                return DateTime.Parse(response.Content, null, System.Globalization.DateTimeStyles.RoundtripKind);
            }

            if (type == typeof(String) || type.Name.StartsWith("System.Nullable")) // return primitive type
            {
                return ConvertType(response.Content, type);
            }

            // at this point, it must be a model (json)
            try
            {
                return JsonConvert.DeserializeObject(response.Content, type, serializerSettings);
            }
            catch (Exception e)
            {
                throw new ApiException(500, e.Message);
            }
        }

        /// <summary>
        /// Serialize an input (model) into JSON string
        /// </summary>
        /// <param name="obj">Object.</param>
        /// <param name="contentType"></param>
        /// <returns>JSON string.</returns>
        public String Serialize(object obj, string contentType = "application/json")
        {
            try
            {
                if (contentType == "text/csv")
                {
                    return obj != null ? SerializeCsvToString(obj) : null;
                }

                return obj != null ? JsonConvert.SerializeObject(obj) : null;
            }
            catch (Exception e)
            {
                throw new ApiException(500, e.Message);
            }
        }

        /// <summary>
        /// SerializeCsvToString - Interim method to Serialize the Request Object to CSV format
        /// </summary>
        /// <param name="obj"></param>
        /// <returns></returns>
        public static String SerializeCsvToString(object obj)
        {
            if (obj == null || obj.GetType() == typeof(String))
                return null;

            StringBuilder sb = new StringBuilder();

            // We expect this object to be a List
            // Get the List Object which resids inside the RequestObject - needs improvement
            var requestObjList = obj.GetType().GetProperties()
                .Select(n => n.GetValue(obj))
                .ToList()
                .FirstOrDefault();

            //for this iteration, we only support BulkRecipient request object 
            sb.Append(SerializeCsvToString((List<object>)requestObjList));

            return sb.ToString();
        }

        /// <summary>
        /// SerializeCsvToString - Interim method to Serialize the Request Object to CSV format
        /// </summary>
        /// <typeparam name="T"></typeparam>
        /// <param name="obj"></param>
        /// <returns></returns>
        public static String SerializeCsvToString<T>(List<T> obj) where T : class
        {
            if (obj == null || obj.GetType() == typeof(String))
                return null;

            string output = string.Empty;
            string csv = ",";

            var properties = typeof(T).GetProperties();

            using (var sw = new StringWriter())
            {
                // Do this only once - get the DataMember name for each property
                var headerRow = new StringBuilder();

                foreach (var property in properties)
                {
                    var dataMembers = property.GetCustomAttributes(typeof(DataMemberAttribute), true);
                    foreach (DataMemberAttribute attr in dataMembers)
                    {
                        headerRow.Append(attr.Name + csv);
                    }
                }
                headerRow.Remove(headerRow.Length - 1, 1);
                sw.WriteLine(headerRow);

                foreach (var item in obj)
                {
                    // Get values of each in the given object
                    var row = properties
                        .Select(x => x.GetValue(item, null))
                        .Select(x => x == null ? "" : x.ToString())
                        .Aggregate((a, b) => a + csv + b);

                    sw.WriteLine(row);
                }

                output = sw.ToString();
            }
            return output;
        }

        /// <summary>
        /// Select the Content-Type header's value from the given content-type array:
        /// if JSON exists in the given array, use it;
        /// otherwise use the first one defined in 'consumes'
        /// </summary>
        /// <param name="contentTypes">The Content-Type array to select from.</param>
        /// <returns>The Content-Type header to use.</returns>
        public String SelectHeaderContentType(String[] contentTypes)
        {
            if (contentTypes.Length == 0)
                return null;

            if (contentTypes.Contains("application/json", StringComparer.OrdinalIgnoreCase))
                return "application/json";

            return contentTypes[0]; // use the first content type specified in 'consumes'
        }

        /// <summary>
        /// Select the Accept header's value from the given accepts array:
        /// if JSON exists in the given array, use it;
        /// otherwise use all of them (joining into a string)
        /// </summary>
        /// <param name="accepts">The accepts array to select from.</param>
        /// <returns>The Accept header to use.</returns>
        public String SelectHeaderAccept(String[] accepts)
        {
            if (accepts.Length == 0)
                return null;

            if (accepts.Contains("application/json", StringComparer.OrdinalIgnoreCase))
                return "application/json";

            return String.Join(",", accepts);
        }

        /// <summary>
        /// Encode string in base64 format.
        /// </summary>
        /// <param name="text">String to be encoded.</param>
        /// <returns>Encoded string.</returns>
        public static string Base64Encode(string text)
        {
            return System.Convert.ToBase64String(System.Text.Encoding.UTF8.GetBytes(text));
        }

        /// <summary>
        /// Dynamically cast the object into target type.
        /// Ref: http://stackoverflow.com/questions/4925718/c-dynamic-runtime-cast
        /// </summary>
        /// <param name="source">Object to be casted</param>
        /// <param name="dest">Target type</param>
        /// <returns>Casted object</returns>
        public static dynamic ConvertType(dynamic source, Type dest)
        {
            return Convert.ChangeType(source, dest);
        }

        /// <summary>
        /// Convert stream to byte array
        /// Credit/Ref: http://stackoverflow.com/a/221941/677735
        /// </summary>
        /// <param name="input">Input stream to be converted</param>
        /// <returns>Byte array</returns>
        public static byte[] ReadAsBytes(Stream input)
        {
            byte[] buffer = new byte[16 * 1024];
            using (MemoryStream ms = new MemoryStream())
            {
                int read;
                while ((read = input.Read(buffer, 0, buffer.Length)) > 0)
                {
                    ms.Write(buffer, 0, read);
                }
                return ms.ToArray();
            }
        }

        /// <summary>
        /// URL encode a string
        /// Credit/Ref: https://github.com/restsharp/RestSharp/blob/master/RestSharp/Extensions/StringExtensions.cs#L50
        /// </summary>
        /// <param name="input">String to be URL encoded</param>
        /// <returns>Byte array</returns>
        public static string UrlEncode(string input)
        {
            const int maxLength = 32766;

            if (input == null)
            {
                throw new ArgumentNullException("input");
            }

            if (input.Length <= maxLength)
            {
                return Uri.EscapeDataString(input);
            }

            StringBuilder sb = new StringBuilder(input.Length * 2);
            int index = 0;

            while (index < input.Length)
            {
                int length = Math.Min(input.Length - index, maxLength);
                string subString = input.Substring(index, length);

                sb.Append(Uri.EscapeDataString(subString));
                index += subString.Length;
            }

            return sb.ToString();
        }

        /// <summary>
        /// Sanitize filename by removing the path
        /// </summary>
        /// <param name="filename">Filename</param>
        /// <returns>Filename</returns>
        public static string SanitizeFilename(string filename)
        {
            Match match = Regex.Match(filename, @".*[/\\](.*)$");

            if (match.Success)
            {
                return match.Groups[1].Value;
            }
            else
            {
                return filename;
            }
        }


        /// <summary>
        /// Gets or sets the Proxy of ApiClient. Default to null
        /// </summary>
        /// <value>Timeout.</value>
        [Obsolete("This property will only return null and can only be set if an HTTP client hasn't already been created via one of the constructors. This property will be removed in a future release.", false)]
        public IWebProxy Proxy
        {
            get => null;

            set
            {
                if (this.RestClient != null)
                {
                    throw new NotSupportedException("Cannot set Proxy if an HTTP client has already been created via one of the ApiClient constructors.");
                }

                this.RestClient = buildDefaultHttpClient(Configuration.DefaultTimeoutValue, value);
                this.RestClient.AddDefaultRequestHeader("User-Agent", Configuration.UserAgent);
            }
        }

        /// <summary>
        /// Helper method to configure the OAuth accessCode/implicit flow parameters
        /// </summary>
        /// <param name="clientId">OAuth2 client ID: Identifies the client making the request.</param>
        /// <param name="scopes">the list of requested scopes.  Client applications may be scoped to a limited set of system access.</param>
        /// <param name="redirectUri">this determines where to deliver the response containing the authorization code or access token.</param>
        /// <param name="responseType">determines the response type of the authorization request.
        /// <br /><i>Note</i>: these response types are mutually exclusive for a client application.
        /// A public/native client application may only request a response type of "token";
        /// a private/trusted client application may only request a response type of "code".</param>
        /// <param name="state">Allows for arbitrary state that may be useful to your application.
        /// The value in this parameter will be round-tripped along with the response so you can make sure it didn't change.</param>
        /// <returns></returns>
        public Uri GetAuthorizationUri(string clientId, List<string> scopes, string redirectUri, string responseType, string state = null)
        {
            string formattedScopes = (scopes == null || scopes.Count < 1) ? "" : scopes[0];
            StringBuilder scopesSb = new StringBuilder(formattedScopes);
            for (int i = 1; i < scopes.Count; i++)
            {
                scopesSb.Append("%20" + scopes[i]);
            }

            UriBuilder builder = new UriBuilder(GetOAuthBasePath())
            {
                Scheme = "https",
                Path = "/oauth/auth",
                Port = 443,
                Query = BuildQueryString(clientId, scopesSb.ToString(), redirectUri, responseType, state)
            };
            return builder.Uri;
        }

        /// <summary>
        /// Builds a QueryString with the given parameters
        /// </summary>
        /// <param name="clientId"></param>
        /// <param name="scopes"></param>
        /// <param name="redirectUri"></param>
        /// <param name="responseType"></param>
        /// <param name="state"></param>
        /// <returns>Formatted Query String</returns>
        protected string BuildQueryString(string clientId, string scopes, string redirectUri, string responseType, string state)
        {
            StringBuilder queryParams = new StringBuilder();
            if (!string.IsNullOrEmpty(responseType) || responseType != null)
            {
                queryParams.Append("response_type=" + responseType);
            }
            if (!string.IsNullOrEmpty(scopes) || scopes != null)
            {
                queryParams.Append("&scope=" + scopes);
            }
            if (!string.IsNullOrEmpty(clientId) || clientId != null)
            {
                queryParams.Append("&client_id=" + clientId);
            }
            if (!string.IsNullOrEmpty(redirectUri) || redirectUri != null)
            {
                queryParams.Append("&redirect_uri=" + redirectUri);
            }
            if (!string.IsNullOrEmpty(state) || state != null)
            {
                queryParams.Append("&state=" + state);
            }

            return queryParams.ToString();
        }

        /// <summary>
        /// GetOAuthBasePath sets the basePath for the user account.
        /// </summary>
        /// <returns>If the current base path is demo then it sets the demo account as the basePath, else it sets the Production account as the basePath.</returns>
        protected string GetOAuthBasePath()
        {
            if (string.IsNullOrEmpty(this.oAuthBasePath))
            {
                this.SetOAuthBasePath();
            }
            return this.oAuthBasePath;
        }

        /// <summary>
        /// Use this method to Set Base Path
        /// </summary>
        /// <param name="basePath"></param>
        public void SetBasePath(string basePath)
        {
            this.basePath = basePath;
            if (Configuration != null)
            {
                Configuration.BasePath = this.basePath;
            }
            else
            {
                Configuration = new Configuration(this.basePath);
            }
        }

        /// <summary>
        /// Use this method to set custom OAuth Base Path.
        /// </summary>
        /// <param name="oauthBaseUri">Optional custom base path value. If not provided we will derive it according to the ApiClient basePath value.</param>
        public void SetOAuthBasePath(string oauthBaseUri = null)
        {
            //Set Custom Base path
            if (!string.IsNullOrEmpty(oauthBaseUri))
            {
                this.oAuthBasePath = oauthBaseUri;
                return;
            }

            //Derive OAuth Base Path if not given.
            if (Uri.TryCreate(this.basePath, UriKind.Absolute, out Uri baseUri))
            {
                if (baseUri.Host.StartsWith("apps-d") || baseUri.Host.StartsWith("demo"))
                {
                    this.oAuthBasePath = OAuth.Demo_OAuth_BasePath;
                }
                else if (baseUri.Host.StartsWith("apps-s") || baseUri.Host.StartsWith("stage"))
                {
                    this.oAuthBasePath = OAuth.Stage_OAuth_BasePath;
                }
                else
                {
                    this.oAuthBasePath = OAuth.Production_OAuth_BasePath;
                }
            }
            else
            {
                this.oAuthBasePath = OAuth.Demo_OAuth_BasePath;
            }
        }

        private static T TryCatchWrapper<T>(Func<T> func)
        {
            try
            {
                return func.Invoke();
            }
            catch (AggregateException ae)
            {
                foreach (var e in ae.InnerExceptions)
                {
                    throw e;
                }

                // This line is technically unreachable, but necessary for the compiler to be happy.
                throw;
            }
            catch (Exception e)
            {

                throw e;
            }
        }

        /// <summary>
        /// GenerateAccessToken will exchange the authorization code for an access token and refresh tokens.
        /// </summary>
        /// <param name="clientId">OAuth2 client ID: Identifies the client making the request.</param>
        /// <param name="clientSecret">the secret key you generated when you set up the integration in Docusign Admin console.</param>
        /// <param name="code">The authorization code that you received from the <i> GetAuthorizationUri </i> callback.</param>
        /// <returns> OAuth.OAuthToken object.
        /// ApiException if the HTTP call status is different than 2xx.
        /// IOException  if there is a problem while parsing the reponse object.
        /// </returns>
        public OAuth.OAuthToken GenerateAccessToken(string clientId, string clientSecret, string code)
        {
            CancellationTokenSource cts = new CancellationTokenSource();
            return TryCatchWrapper(() => GenerateAccessTokenAsync(clientId, clientSecret, code, cts.Token).ConfigureAwait(false).GetAwaiter().GetResult());
        }

        /// <summary>
        /// GenerateAccessTokenAsync will exchange the authorization code for an access token and refresh tokens.
        /// </summary>
        /// <param name="clientId">OAuth2 client ID: Identifies the client making the request.</param>
        /// <param name="clientSecret">the secret key you generated when you set up the integration in Docusign Admin console.</param>
        /// <param name="code">The authorization code that you received from the <i> GetAuthorizationUri </i> callback.</param>
        /// <param name="cancellationToken">A CancellationToken which can be used to propagate notification that operations should be canceled. </param>
        /// <returns> 
        /// Task&lt;OAuth.OAuthToken&gt; object.
        /// ApiException if the HTTP call status is different than 2xx.
        /// IOException  if there is a problem while parsing the reponse object.
        /// </returns>
        public async Task<OAuth.OAuthToken> GenerateAccessTokenAsync(string clientId, string clientSecret, string code, CancellationToken cancellationToken)
        {
            if (string.IsNullOrEmpty(clientId) || string.IsNullOrEmpty(clientSecret) || string.IsNullOrEmpty(code))
            {
                throw new ArgumentNullException();
            }

            string codeAuth = (clientId ?? "") + ":" + (clientSecret ?? "");
            byte[] codeAuthBytes = Encoding.UTF8.GetBytes(codeAuth);
            string codeAuthBase64 = Convert.ToBase64String(codeAuthBytes);

            DocuSignRequest request = new DocuSignRequest(HttpMethod.Post, $"{oAuthBasePathWithScheme}oauth/token", "");

            request.AddHeaderParameter("Authorization", "Basic " + codeAuthBase64);
            request.AddHeaderParameter("Content-Type", "application/x-www-form-urlencoded");
            // Don't cache authentication requests
            request.AddHeaderParameter("Cache-Control", "no-store");
            request.AddHeaderParameter("Pragma", "no-cache");

            Dictionary<string, string> formParams = new Dictionary<string, string>
            {
                { "grant_type", "authorization_code" },
                { "code", code }
            };

            foreach (var item in formParams)
                request.AddPostParameter(item.Key, item.Value);

            DocuSignResponse response = await RestClient.SendRequestAsync(request, cancellationToken);
            if (response.StatusCode >= HttpStatusCode.OK && response.StatusCode < HttpStatusCode.BadRequest)
            {
                OAuth.OAuthToken tokenObj = JsonConvert.DeserializeObject<OAuth.OAuthToken>(response.Content);
                // Add the token to this ApiClient
                string authHeader = "Bearer " + tokenObj.access_token;
                this.Configuration.DefaultHeader["Authorization"] = authHeader;
                return tokenObj;
            }
            else
            {
                throw CreateApiExceptionFromDocuSignResponse(response);
            }
        }

        /// <summary>
        /// GetUserInfo method takes the accessToken to retrieve User Account Data.
        /// </summary>
        /// <param name="accessToken"></param>
        /// <returns>The User Info model.</returns>
        public OAuth.UserInfo GetUserInfo(string accessToken)
        {
            CancellationTokenSource cts = new CancellationTokenSource();
            return TryCatchWrapper(() => GetUserInfoAsync(accessToken, cts.Token).ConfigureAwait(false).GetAwaiter().GetResult());
        }

        /// <summary>
        /// GetUserInfoAsync method takes the accessToken to retrieve User Account Data.
        /// </summary>
        /// <param name="accessToken"></param>
        /// <param name="cancellationToken">A CancellationToken which can be used to propagate notification that operations should be canceled. </param>
        /// <returns>The User Info model.</returns>
        public async Task<OAuth.UserInfo> GetUserInfoAsync(string accessToken, CancellationToken cancellationToken)
        {
            if (string.IsNullOrEmpty(accessToken))
            {
                throw new ArgumentException("Cannot find a valid access token. Make sure OAuth is configured before you try again.");
            }

            var localVarFormParams = new Dictionary<String, String>();
            var localVarHeaderParams = new Dictionary<String, String>(Configuration.DefaultHeader);
            if (localVarHeaderParams.ContainsKey("Authorization")) { localVarHeaderParams.Remove("Authorization"); }
            localVarHeaderParams.Add("Authorization", "Bearer " + accessToken);

            DocuSignRequest request = PrepareOAuthRequest(oAuthBasePath, $"oauth/userinfo", HttpMethod.Get, localVarHeaderParams.ToList(), localVarFormParams.ToList());
            DocuSignResponse response = await RestClient.SendRequestAsync(request, cancellationToken);

            if (response.StatusCode >= HttpStatusCode.OK && response.StatusCode < HttpStatusCode.BadRequest)
            {
                OAuth.UserInfo userInfo = JsonConvert.DeserializeObject<OAuth.UserInfo>(response.Content);
                return userInfo;
            }
            else
            {
                throw CreateApiExceptionFromDocuSignResponse(response);
            }
        }

        /// <summary>
        /// Creates an RSA Key from the given PEM key.
        /// </summary>
        /// <param name="key"></param>
        /// <returns>RSACryptoServiceProvider using the "key"</returns>
        protected static RSA CreateRSAKeyFromPem(string key)
        {
            TextReader reader = new StringReader(key);
            PemReader pemReader = new PemReader(reader);

            object result = pemReader.ReadObject();

            RSA provider = RSA.Create();

            if (result is AsymmetricCipherKeyPair keyPair)
            {
                var rsaParams = DotNetUtilities.ToRSAParameters((RsaPrivateCrtKeyParameters)keyPair.Private);
                provider.ImportParameters(rsaParams);
                return provider;
            }
            else if (result is RsaKeyParameters keyParameters)
            {
                var rsaParams = DotNetUtilities.ToRSAParameters(keyParameters);
                provider.ImportParameters(rsaParams);
                return provider;
            }

            throw new Exception("Unexpected PEM type");
        }

        /// <summary>
        /// RequestJWTUserToken
        /// Configures the current instance of ApiClient with a fresh OAuth JWT access token from Docusign
        /// </summary>
        /// <param name="clientId">Docusign OAuth Client Id(AKA Integrator Key)</param>
        /// <param name="userId">Docusign user Id to be impersonated(This is a UUID)</param>
        /// <param name="oauthBasePath"> Docusign OAuth base path
        /// <see cref="OAuth.Demo_OAuth_BasePath"/> <see cref="OAuth.Production_OAuth_BasePath"/> <see cref="OAuth.Stage_OAuth_BasePath"/>
        /// <seealso cref="GetOAuthBasePath()" /> <seealso cref="SetOAuthBasePath(string)"/>
        /// </param>
        /// <param name="privateKeyStream">The Stream of the RSA private key</param>
        /// <param name="expiresInHours">Number of hours remaining before the JWT assertion is considered as invalid</param>
        /// <param name="scopes">Optional. The list of requested scopes may include (but not limited to)
        /// <see cref="OAuth.Scope_SIGNATURE"/> <see cref="OAuth.Scope_IMPERSONATION"/> <see cref="OAuth.Scope_EXTENDED"/>
        /// </param>
        /// <returns>The JWT user token</returns>
        public OAuth.OAuthToken RequestJWTUserToken(string clientId, string userId, string oauthBasePath, Stream privateKeyStream, int expiresInHours, List<string> scopes = null)
        {
            CancellationTokenSource cts = new CancellationTokenSource();
            return TryCatchWrapper(() => RequestJWTUserTokenAsync(clientId, userId, oauthBasePath, privateKeyStream, expiresInHours, scopes, cts.Token).ConfigureAwait(false).GetAwaiter().GetResult());
        }

        /// <summary>
        /// RequestJWTUserTokenAsync
        /// Configures the current instance of ApiClient with a fresh OAuth JWT access token from Docusign
        /// </summary>
        /// <param name="clientId">Docusign OAuth Client Id(AKA Integrator Key)</param>
        /// <param name="userId">Docusign user Id to be impersonated(This is a UUID)</param>
        /// <param name="oauthBasePath"> Docusign OAuth base path
        /// <see cref="OAuth.Demo_OAuth_BasePath"/> <see cref="OAuth.Production_OAuth_BasePath"/> <see cref="OAuth.Stage_OAuth_BasePath"/>
        /// <seealso cref="GetOAuthBasePath()" /> <seealso cref="SetOAuthBasePath(string)"/>
        /// </param>
        /// <param name="privateKeyStream">The Stream of the RSA private key</param>
        /// <param name="expiresInHours">Number of hours remaining before the JWT assertion is considered as invalid</param>
        /// <param name="scopes">Optional. The list of requested scopes may include (but not limited to)
        /// <param name="cancellationToken">A CancellationToken which can be used to propagate notification that operations should be canceled. </param>
        /// <see cref="OAuth.Scope_SIGNATURE"/> <see cref="OAuth.Scope_IMPERSONATION"/> <see cref="OAuth.Scope_EXTENDED"/>
        /// </param>
        /// <returns>The JWT user token</returns>
        public Task<OAuth.OAuthToken> RequestJWTUserTokenAsync(string clientId, string userId, string oauthBasePath, Stream privateKeyStream, int expiresInHours, List<string> scopes = null, CancellationToken cancellationToken = default)
        {
            if (privateKeyStream != null && privateKeyStream.CanRead && privateKeyStream.Length > 0)
            {
                byte[] privateKeyBytes = ReadAsBytes(privateKeyStream);
                return this.RequestJWTUserTokenAsync(clientId, userId, oauthBasePath, privateKeyBytes, expiresInHours, scopes, cancellationToken);
            }
            else
            {
                throw new ApiException(400, "Private key stream not supplied or is invalid!");
            }
        }

        /// <summary>
        /// RequestJWTUserToken
        /// Configures the current instance of ApiClient with a fresh OAuth JWT access token from Docusign
        /// </summary>
        /// <param name="clientId">Docusign OAuth Client Id(AKA Integrator Key)</param>
        /// <param name="userId">Docusign user Id to be impersonated(This is a UUID)</param>
        /// <param name="oauthBasePath"> Docusign OAuth base path
        /// <see cref="OAuth.Demo_OAuth_BasePath"/> <see cref="OAuth.Production_OAuth_BasePath"/> <see cref="OAuth.Stage_OAuth_BasePath"/>
        /// <seealso cref="GetOAuthBasePath()" /> <seealso cref="SetOAuthBasePath(string)"/>
        /// </param>
        /// <param name="privateKeyBytes">The byte contents of the RSA private key</param>
        /// <param name="expiresInHours">Number of hours remaining before the JWT assertion is considered as invalid</param>
        /// <param name="scopes">Optional. The list of requested scopes may include (but not limited to) You can also pass any advanced scope.
        /// <see cref="OAuth.Scope_SIGNATURE"/> <see cref="OAuth.Scope_IMPERSONATION"/> <see cref="OAuth.Scope_EXTENDED"/>
        /// </param>
        /// <returns>The JWT user token</returns>
        public OAuth.OAuthToken RequestJWTUserToken(string clientId, string userId, string oauthBasePath, byte[] privateKeyBytes, int expiresInHours, List<string> scopes = null)
        {
            CancellationTokenSource cts = new CancellationTokenSource();
            return TryCatchWrapper(() => RequestJWTUserTokenAsync(clientId, userId, oauthBasePath, privateKeyBytes, expiresInHours, scopes, cts.Token).ConfigureAwait(false).GetAwaiter().GetResult());
        }

        /// <summary>
        /// RequestJWTUserTokenAsync
        /// Configures the current instance of ApiClient with a fresh OAuth JWT access token from Docusign
        /// </summary>
        /// <param name="clientId">Docusign OAuth Client Id(AKA Integrator Key)</param>
        /// <param name="userId">Docusign user Id to be impersonated(This is a UUID)</param>
        /// <param name="oauthBasePath"> Docusign OAuth base path
        /// <see cref="OAuth.Demo_OAuth_BasePath"/> <see cref="OAuth.Production_OAuth_BasePath"/> <see cref="OAuth.Stage_OAuth_BasePath"/>
        /// <seealso cref="GetOAuthBasePath()" /> <seealso cref="SetOAuthBasePath(string)"/>
        /// </param>
        /// <param name="privateKeyBytes">The byte contents of the RSA private key</param>
        /// <param name="expiresInHours">Number of hours remaining before the JWT assertion is considered as invalid</param>
        /// <param name="scopes">Optional. The list of requested scopes may include (but not limited to) You can also pass any advanced scope.
        /// <param name="cancellationToken">A CancellationToken which can be used to propagate notification that operations should be canceled. </param>
        /// <see cref="OAuth.Scope_SIGNATURE"/> <see cref="OAuth.Scope_IMPERSONATION"/> <see cref="OAuth.Scope_EXTENDED"/>
        /// </param>
        /// <returns>The JWT user token</returns>
        public async Task<OAuth.OAuthToken> RequestJWTUserTokenAsync(string clientId, string userId, string oauthBasePath, byte[] privateKeyBytes, int expiresInHours, List<string> scopes = null, CancellationToken cancellationToken = default)
        {
            string privateKey = Encoding.UTF8.GetString(privateKeyBytes);

            JsonWebTokenHandler handler = new JsonWebTokenHandler
            {
                SetDefaultTimesOnTokenCreation = false
            };

            SecurityTokenDescriptor descriptor = new SecurityTokenDescriptor()
            {
                Expires = DateTime.UtcNow.AddHours(expiresInHours),
                IssuedAt = DateTime.UtcNow,
            };

            scopes = scopes ?? new List<string> { OAuth.Scope_SIGNATURE };

            descriptor.Subject = new ClaimsIdentity();
            descriptor.Subject.AddClaim(new Claim("scope", String.Join(" ", scopes)));
            descriptor.Subject.AddClaim(new Claim("aud", oauthBasePath));
            descriptor.Subject.AddClaim(new Claim("iss", clientId));

            if (!string.IsNullOrEmpty(userId))
            {
                descriptor.Subject.AddClaim(new Claim("sub", userId));
            }
            else
            {
                throw new ApiException(400, "User Id not supplied or is invalid!");
            }

            if (!string.IsNullOrEmpty(privateKey))
            {
                var rsa = CreateRSAKeyFromPem(privateKey);
                RsaSecurityKey rsaKey = new RsaSecurityKey(rsa);
                descriptor.SigningCredentials = new SigningCredentials(rsaKey, SecurityAlgorithms.RsaSha256Signature);
            }
            else
            {
                throw new ApiException(400, "Private key not supplied or is invalid!");
            }

            var jwtToken = handler.CreateToken(descriptor);

            var localVarFormParams = new Dictionary<string, string>
            {
                { "grant_type", OAuth.Grant_Type_JWT },
                { "assertion", jwtToken }
            };

            DocuSignRequest request = PrepareOAuthRequest(oauthBasePath, $"oauth/token", HttpMethod.Post, Configuration.DefaultHeader?.ToList(), localVarFormParams.ToList());
            DocuSignResponse response = await RestClient.SendRequestAsync(request, cancellationToken);

            if (response.StatusCode >= HttpStatusCode.OK && response.StatusCode < HttpStatusCode.BadRequest)
            {
                OAuth.OAuthToken tokenInfo = JsonConvert.DeserializeObject<OAuth.OAuthToken>(response.Content);
                this.Configuration.DefaultHeader["Authorization"] = string.Format("{0} {1}", tokenInfo.token_type, tokenInfo.access_token);

                return tokenInfo;
            }
            else
            {
                throw CreateApiExceptionFromDocuSignResponse(response);
            }
        }

        /// <summary>
        /// *RESERVED FOR PARTNERS* RequestJWTApplicationToken
        /// </summary>
        /// <param name="clientId">Docusign OAuth Client Id(AKA Integrator Key)</param>
        /// <param name="oauthBasePath"> Docusign OAuth base path
        /// <see cref="OAuth.Demo_OAuth_BasePath"/> <see cref="OAuth.Production_OAuth_BasePath"/> <see cref="OAuth.Stage_OAuth_BasePath"/>
        /// <seealso cref="GetOAuthBasePath()" /> <seealso cref="SetOAuthBasePath(string)"/>
        /// </param>
        /// <param name="privateKeyBytes">The byte contents of the RSA private key</param>
        /// <param name="expiresInHours">Number of hours remaining before the JWT assertion is considered as invalid</param>
        /// <param name="scopes">Optional. The list of requested scopes may include (but not limited to) You can also pass any advanced scope.
        /// <see cref="OAuth.Scope_SIGNATURE"/> <see cref="OAuth.Scope_IMPERSONATION"/> <see cref="OAuth.Scope_EXTENDED"/>
        /// </param>
        /// <returns>The JWT application token</returns>
        public OAuth.OAuthToken RequestJWTApplicationToken(string clientId, string oauthBasePath, byte[] privateKeyBytes, int expiresInHours, List<string> scopes = null)
        {
            CancellationTokenSource cts = new CancellationTokenSource();
            return TryCatchWrapper(() => RequestJWTApplicationTokenAsync(clientId, oAuthBasePath, privateKeyBytes, expiresInHours, scopes, cts.Token).ConfigureAwait(false).GetAwaiter().GetResult());
        }

        /// <summary>
        /// *RESERVED FOR PARTNERS* RequestJWTApplicationTokenAsync
        /// </summary>
        /// <param name="clientId">Docusign OAuth Client Id(AKA Integrator Key)</param>
        /// <param name="oauthBasePath"> Docusign OAuth base path
        /// <see cref="OAuth.Demo_OAuth_BasePath"/> <see cref="OAuth.Production_OAuth_BasePath"/> <see cref="OAuth.Stage_OAuth_BasePath"/>
        /// <seealso cref="GetOAuthBasePath()" /> <seealso cref="SetOAuthBasePath(string)"/>
        /// </param>
        /// <param name="privateKeyBytes">The byte contents of the RSA private key</param>
        /// <param name="expiresInHours">Number of hours remaining before the JWT assertion is considered as invalid</param>
        /// <param name="scopes">Optional. The list of requested scopes may include (but not limited to) You can also pass any advanced scope.
        /// <param name="cancellationToken">A CancellationToken which can be used to propagate notification that operations should be canceled. </param>
        /// <see cref="OAuth.Scope_SIGNATURE"/> <see cref="OAuth.Scope_IMPERSONATION"/> <see cref="OAuth.Scope_EXTENDED"/>
        /// </param>
        /// <returns>The JWT application token</returns>
        public async Task<OAuth.OAuthToken> RequestJWTApplicationTokenAsync(string clientId, string oauthBasePath, byte[] privateKeyBytes, int expiresInHours, List<string> scopes = null, CancellationToken cancellationToken = default)
        {
            string privateKey = Encoding.UTF8.GetString(privateKeyBytes);

            JsonWebTokenHandler handler = new JsonWebTokenHandler();

            SecurityTokenDescriptor descriptor = new SecurityTokenDescriptor()
            {
                Expires = DateTime.UtcNow.AddHours(expiresInHours),
            };

            scopes = scopes ?? new List<string> { OAuth.Scope_SIGNATURE };

            descriptor.Subject = new ClaimsIdentity();
            descriptor.Subject.AddClaim(new Claim("scope", String.Join(" ", scopes)));
            descriptor.Subject.AddClaim(new Claim("aud", oauthBasePath));
            descriptor.Subject.AddClaim(new Claim("iss", clientId));

            if (!string.IsNullOrEmpty(privateKey))
            {
                var rsa = CreateRSAKeyFromPem(privateKey);
                RsaSecurityKey rsaKey = new RsaSecurityKey(rsa);
                descriptor.SigningCredentials = new SigningCredentials(rsaKey, SecurityAlgorithms.RsaSha256Signature);
            }
            else
            {
                throw new ApiException(400, "Private key not supplied or is invalid!");
            }

            var jwtToken = handler.CreateToken(descriptor);

            var localVarFormParams = new Dictionary<string, string>
            {
                { "grant_type", OAuth.Grant_Type_JWT },
                { "assertion", jwtToken }
            };

            DocuSignRequest request = PrepareOAuthRequest(oauthBasePath, $"oauth/token", HttpMethod.Post, Configuration.DefaultHeader?.ToList(), localVarFormParams.ToList());
            DocuSignResponse response = await RestClient.SendRequestAsync(request, cancellationToken);

            if (response.StatusCode >= HttpStatusCode.OK && response.StatusCode < HttpStatusCode.BadRequest)
            {
                OAuth.OAuthToken tokenInfo = JsonConvert.DeserializeObject<OAuth.OAuthToken>(response.Content);
                this.Configuration.DefaultHeader["Authorization"] = string.Format("{0} {1}", tokenInfo.token_type, tokenInfo.access_token);
                return tokenInfo;
            }
            else
            {
                throw CreateApiExceptionFromDocuSignResponse(response);
            }
        }

        private ApiException CreateApiExceptionFromDocuSignResponse(DocuSignResponse response)
        {
            var hasContent = !string.IsNullOrWhiteSpace(response.Content);

            return new ApiException((int)response.StatusCode,
                            "Error while requesting server, received a non successful HTTP code with response Body: " + (hasContent ? response.Content : response.ErrorMessage),
                            (hasContent ? (dynamic)response.Content : response.Exception),
                            response);
        }

    }
}
